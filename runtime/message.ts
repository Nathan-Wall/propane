import { normalizeForJson } from './common/json/stringify.js';
import { ImmutableMap } from './common/map/immutable.js';
import { ImmutableSet } from './common/set/immutable.js';
import { ImmutableArray } from './common/array/immutable.js';
import { ImmutableArrayBuffer } from './common/data/immutable-array-buffer.js';
import { ImmutableDate } from './common/time/date.js';
import { ImmutableUrl } from './common/web/url.js';
import {
  SET_UPDATE_LISTENER,
  FROM_ROOT,
  REGISTER_PATH,
  PROPAGATE_UPDATE,
  WITH_CHILD,
  GET_MESSAGE_CHILDREN,
  EQUALS_FROM_ROOT,

} from './symbols.js';
import { needsDetach, detachValue } from './common/detach.js';

const SIMPLE_STRING_RE = /^[A-Za-z0-9 _-]+$/;
const RESERVED_STRINGS = new Set(['true', 'false', 'null', 'undefined']);
const NUMERIC_STRING_RE = /^-?\d+(?:\.\d+)?$/;
const DATE_PREFIX = 'D';
const URL_PREFIX = 'U';
const ARRAY_BUFFER_PREFIX = 'B';

export type DataPrimitive =
  | string
  | number
  | boolean
  | null
  | undefined;
export type DataValue =
  | DataPrimitive
  | Date
  | ImmutableDate
  | URL
  | ImmutableUrl
  | ArrayBuffer
  | ImmutableArrayBuffer
  | ImmutableMap<unknown, unknown>
  | ImmutableSet<unknown>
  | Map<unknown, unknown>
  | Set<unknown>
  | Iterable<unknown>
  | TaggedMessageData
  | DataObject
  | DataArray
  | Message<any>;
export type DataArray = DataValue[];
export interface DataObject {
  [key: string]: DataValue;
}
export type MapKey =
  | DataPrimitive
  | Date
  | ImmutableDate
  | URL
  | ImmutableUrl;

export interface TaggedMessageData {
  $tag: string;
  $data: DataObject;
}

export function isTaggedMessageData(
  value: unknown
): value is TaggedMessageData {
  return (
    value !== null
    && typeof value === 'object'
    && '$tag' in value
    && '$data' in value
    && typeof (value as TaggedMessageData).$tag === 'string'
  );
}




export interface MessagePropDescriptor<T extends object> {
  name: keyof T;
  fieldNumber: number | null;
  getValue: () => T[keyof T];
  /**
   * When present, indicates the value should be tagged for
   * union discrimination
   */
  unionMessageTypes?: string[];
}

/**
 * Interface for generic message constructors.
 * Used when passing constructors to generic message classes.
 * Uses Message<any> constraint to allow generic types like Response<T>
 * where T extends Message<any>.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export interface MessageConstructor<T extends Message<any>> {
  new (props: unknown): T;
  deserialize(data: string): T;
  readonly $typeName: string;
}

type MessageFromEntries<T extends DataObject> = Message<T> & {
  $fromEntries(entries: Record<string, unknown>): T;
};

interface InternalMessageConstructor<T extends DataObject> {
  new(props: T): Message<T>;
  prototype: MessageFromEntries<T>;
}

// Intern pool for message instances, keyed by serialized form
// Uses WeakRef to allow garbage collection of unused instances
const internPool = new Map<string, WeakRef<Message<DataObject>>>();
const registry = new FinalizationRegistry<string>((key) => {
  const ref = internPool.get(key);
  if (ref && !ref.deref()) {
    internPool.delete(key);
  }
});

// Type for parent chain entry
type ParentType =
  | Message<DataObject>
  | ImmutableArray<unknown>
  | ImmutableMap<unknown, unknown>
  | ImmutableSet<unknown>;

interface ParentChainEntry {
  parent: WeakRef<ParentType>;
  key: string | number;
}

// Type for update listener callback
type UpdateListenerCallback = (msg: Message<DataObject>) => void;

export abstract class Message<T extends DataObject> {
  readonly #typeTag: symbol;
  readonly #typeName: string;
  static readonly MAX_CACHED_SERIALIZE = 64 * 1024; // 64KB
  #serialized?: string;
  #hash?: number;
  #detachedCache?: Message<T>;

  // Path tracking for equality comparisons
  readonly #fromRoot = new WeakMap<Message<DataObject>, string>();

  // Parent chains for update propagation (keyed by listener symbol)
  readonly #parentChains = new Map<symbol, ParentChainEntry>();

  // Callbacks for update propagation (keyed by listener symbol)
  readonly #callbacks = new Map<symbol, UpdateListenerCallback>();

  protected abstract $getPropDescriptors(): MessagePropDescriptor<T>[];
  protected abstract $fromEntries(entries: Record<string, unknown>): T;

  /**
   * Create a new message with a child replaced at the given key.
   * Generated by Babel plugin for each message type.
   */
  public [WITH_CHILD](
    unused_key: string | number,
    unused_child: ParentType
  ): this {
    const msg = `${this.#typeName}[WITH_CHILD] not implemented.`;
    throw new Error(`${msg} Regenerate with updated Babel plugin.`);
  }

  /**
   * Get all message children for propagating listeners.
   * Generated by Babel plugin for each message type.
   */
  public *[GET_MESSAGE_CHILDREN](): Iterable<[string | number, ParentType]> {
    // Default: no children. Override in generated classes.
  }

  protected constructor(
    typeTag: symbol,
    typeName: string
  ) {
    this.#typeTag = typeTag;
    this.#typeName = typeName;
  }

  protected $update(value: this): this {
    // Propagate update to parent chains
    this.$propagateUpdates(value);
    return value;
  }

  // ============================================
  // HYBRID APPROACH: Path Registration
  // ============================================

  /**
   * Register the path from a root message to this message.
   * Called during parent construction to set up path tracking.
   */
  public [REGISTER_PATH](root: Message<DataObject>, path: string): void {
    this.#fromRoot.set(root, path);
    // Recursively register children
    for (const [key, child] of this[GET_MESSAGE_CHILDREN]()) {
      if (child instanceof Message) {
        child[REGISTER_PATH](root, `${path}.${key}`);
      } else if (child && typeof child === 'object' && REGISTER_PATH in child) {
        (child as { [REGISTER_PATH]: (root: Message<DataObject>, path: string) => void })[REGISTER_PATH](root, `${path}.${key}`);
      }
    }
  }

  /**
   * Get the path from a root to this message.
   */
  public [FROM_ROOT](root: Message<DataObject>): string | undefined {
    return this.#fromRoot.get(root);
  }

  // ============================================
  // HYBRID APPROACH: Path-Aware Equality
  // ============================================

  /**
   * Check equality considering position in the state tree.
   * Two messages are equal from a root if they have the same content
   * AND are at the same path from that root.
   */
  public [EQUALS_FROM_ROOT](
    root: Message<DataObject> | null,
    other: Message<DataObject>
  ): boolean {
    // Content must be equal first
    if (!this.equals(other)) return false;

    // No root context, fall back to content equality
    if (!root) return true;

    const myPath = this.#fromRoot.get(root);
    const otherPath = other[FROM_ROOT](root);

    // If either doesn't have a path from this root, fall back to content equality
    if (myPath === undefined || otherPath === undefined) return true;

    // Same content AND same path = truly equal
    return myPath === otherPath;
  }

  // ============================================
  // HYBRID APPROACH: Update Listener Management
  // ============================================

  /**
   * Set up the parent chain for a given listener key.
   * Called by parent to establish the update propagation path.
   */
  public $setParentChain(
    key: symbol,
    parent: ParentType,
    parentKey: string | number
  ): void {
    this.#parentChains.set(key, {
      parent: new WeakRef(parent),
      key: parentKey,
    });
  }

  /**
   * Set an update listener for a given symbol key.
   * Replaces any existing listener for that key.
   * Propagates the listener setup to all children.
   */
  public [SET_UPDATE_LISTENER](
    key: symbol,
    callback: UpdateListenerCallback
  ): void {
    // Store the callback at this level
    this.#callbacks.set(key, callback);

    // Propagate to children, setting up their parent chains
    for (const [childKey, child] of this[GET_MESSAGE_CHILDREN]()) {
      if (child instanceof Message) {
        // Set up parent chain for this child
        const self = this as unknown as Message<DataObject>;
        child.$setParentChain(key, self, childKey);
        // Recursively set up listener on child
        child[SET_UPDATE_LISTENER](key, callback);
      } else if (
        child && typeof child === 'object' && SET_UPDATE_LISTENER in child
      ) {
        // Handle ImmutableArray/Map/Set
        type CollectionListener = {
          [SET_UPDATE_LISTENER]: (
            key: symbol,
            callback: UpdateListenerCallback,
            parent: Message<DataObject>,
            parentKey: string | number
          ) => void;
        };
        const collection = child as CollectionListener;
        const self = this as unknown as Message<DataObject>;
        collection[SET_UPDATE_LISTENER](key, callback, self, childKey);
      }
    }
  }

  // ============================================
  // HYBRID APPROACH: Update Propagation
  // ============================================

  /**
   * Propagate an update from a child to the root.
   * Walks up the parent chain, creating new messages at each level.
   */
  public [PROPAGATE_UPDATE](
    key: symbol,
    replacement: Message<DataObject>
  ): void {
    const chain = this.#parentChains.get(key);

    if (chain?.parent.deref()) {
      const parent = chain.parent.deref();
      if (parent instanceof Message) {
        // Create new parent with replacement at this position
        const newParent = parent[WITH_CHILD](chain.key, replacement);
        parent[PROPAGATE_UPDATE](key, newParent);
      }
      // Note: For collections, they handle their own propagation
    } else {
      // Reached root - invoke callback with the replacement
      const callback = this.#callbacks.get(key);
      if (callback) {
        callback(replacement);
      }
    }
  }

  /**
   * Called by setters to propagate updates for all registered listeners.
   */
  protected $propagateUpdates(replacement: this): void {
    // Propagate for all listener keys
    for (const key of this.#parentChains.keys()) {
      const r = replacement as unknown as Message<DataObject>;
      this[PROPAGATE_UPDATE](key, r);
    }
    // Also invoke callbacks at root level if this is a root
    for (const key of this.#callbacks.keys()) {
      if (!this.#parentChains.has(key)) {
        const callback = this.#callbacks.get(key);
        if (callback) {
          callback(replacement as unknown as Message<DataObject>);
        }
      }
    }
  }

  get $typeName(): string {
    return this.#typeName;
  }

  /**
   * Check if this message has any active listeners (parent chains or callbacks).
   */
  private hasActiveListeners(): boolean {
    return this.#parentChains.size > 0 || this.#callbacks.size > 0;
  }

  /**
   * Create a copy of this message detached from the state tree.
   * Recursively detaches all child properties.
   *
   * The returned message has no listeners - calling setters on it will return
   * new instances but won't trigger React state updates. Use this to pass
   * data to components or functions that shouldn't be able to update state.
   *
   * Results are cached and reused as long as the cached message has no
   * listeners added to it.
   *
   * @example
   * // Pass detached data to a child component
   * <ChildComponent data={message.detach()} />
   *
   * @example
   * // Prevent accidental state updates in a callback
   * processData(message.detach());
   */
  detach(): this {
    // Return this if no listeners on this message or any children
    if (!this.hasActiveListeners()) {
      const descriptors = this.$getPropDescriptors();
      let childNeedsDetach = false;
      for (const descriptor of descriptors) {
        if (needsDetach(descriptor.getValue())) {
          childNeedsDetach = true;
          break;
        }
      }
      if (!childNeedsDetach) {
        return this;
      }
    }

    // Reuse cached detached message (detached messages never have listeners)
    if (this.#detachedCache) {
      return this.#detachedCache as this;
    }

    const descriptors = this.$getPropDescriptors();
    const entries: Record<string, unknown> = {};
    for (const descriptor of descriptors) {
      entries[String(descriptor.name)] = detachValue(descriptor.getValue());
    }

    const Constructor = this.constructor as new (props: T) => this;

    const detached = new Constructor(this.$fromEntries(entries));
    this.#detachedCache = detached;
    return detached;
  }

  // Immutable.js compatibility: provide a stable hash based on canonical
  // serialization.
  hashCode(): number {
    if (this.#hash !== undefined) {
      return this.#hash;
    }

    const serialized = this.serialize();
    const hash = hashString(serialized);

    // Messages are immutable; cache the hash even if the serialized string was too
    // large to retain.
    this.#hash = hash;

    return hash;
  }

  equals(other: unknown): boolean {
    if (this === other) {
      return true;
    }

    if (!other || typeof other !== 'object') {
      return false;
    }

    if (!(other instanceof Message)) {
      return false;
    }

    if (other.#typeTag !== this.#typeTag) {
      return false;
    }

    // Fast path: if hash codes differ, objects are definitely not equal
    if (this.hashCode() !== other.hashCode()) {
      return false;
    }

    // Hash codes match - need full comparison to confirm equality
    return this.serialize() === other.serialize();
  }

  private cerealize(): T {
    return this.cerealizeWithDescriptors(this.$getPropDescriptors());
  }

  private cerealizeWithDescriptors(descriptors: MessagePropDescriptor<T>[]): T {
    return descriptors.reduce((acc, descriptor) => {
      acc[descriptor.name] = descriptor.getValue();
      return acc;
    }, {} as T);
  }

  serialize(): string {
    if (this.#serialized !== undefined) {
      return this.#serialized;
    }

    const descriptors = this.$getPropDescriptors();
    const entries: ObjectEntry[] = [];
    let expectedIndex = 1;

    for (const descriptor of descriptors) {
      const value = descriptor.getValue();
      const tagMessages = (descriptor.unionMessageTypes?.length ?? 0) > 0;

      if (descriptor.fieldNumber == null) {
        entries.push({ key: String(descriptor.name), value, tagMessages });
        continue;
      }

      if (value === undefined) {
        continue;
      }

      const fieldNumber = descriptor.fieldNumber;
      const shouldOmitKey = fieldNumber === expectedIndex;

      entries.push({
        key: shouldOmitKey ? null : String(fieldNumber),
        value,
        tagMessages,
      });

      expectedIndex = fieldNumber + 1;
    }

    const serialized = `:${serializeObjectLiteral(entries)}`;

    // Avoid retaining excessively large payloads to protect memory usage.
    if (serialized.length <= Message.MAX_CACHED_SERIALIZE) {
      this.#serialized = serialized;
    }

    return serialized;
  }

  /**
   * Provide a JSON-friendly view; JSON.stringify(Message) will emit the plain
   * object form rather than the Propane cereal string.
   * This is primarily provided for debugging purposes.
   * Note that serialization via this method or JSON.stringify is lossy, and
   * all data cannot be reassemled to a Message.
   * Use `serialize()` for serialization.
   */
  toJSON(): unknown {
    return normalizeForJson(this.cerealize());
  }

  static deserialize<T extends DataObject>(
    this: InternalMessageConstructor<T>,
    message: string
  ): Message<T> {
    const payload = parseCerealString(message);
    const proto = this.prototype;
    const props = proto.$fromEntries(payload as Record<string, unknown>);
    return new this(props);
  }

  /**
   * Returns a canonical instance for this message.
   * If an equivalent message has been interned before, returns that instance.
   * Otherwise, interns this message and returns it.
   */
  private intern(): this {
    // Messages with listeners should be detached before interning
    const toIntern = this.hasActiveListeners() ? this.detach() : this;

    const key = toIntern.serialize();
    const existing = internPool.get(key)?.deref();

    if (existing && existing.#typeTag === toIntern.#typeTag) {
      return existing as unknown as this;
    }

    const ref = new WeakRef(toIntern as unknown as Message<DataObject>);
    internPool.set(key, ref);
    registry.register(toIntern, key);
    return toIntern;
  }
}

export function parseCerealString(value: string) {
  if (!value.startsWith(':')) {
    throw new Error('Invalid Propane message. Expected ":" prefix.');
  }
  return new CerealParser(value, 1).parse();
}

class CerealParser {
  private cursor: number;
  private readonly source: string;
  private readonly length: number;

  constructor(source: string, start = 0) {
    this.source = source;
    this.cursor = start;
    this.length = source.length;
  }

  parse(): unknown {
    this.skipWhitespace();
    if (this.cursor >= this.length) {
      throw new Error('Unexpected end of input.');
    }
    const value = this.parseValue();
    this.skipWhitespace();
    if (this.cursor < this.length) {
      throw new Error('Unexpected characters after end of message.');
    }
    return value;
  }

  private parseValue(): unknown {
    this.skipWhitespace();
    if (this.cursor >= this.length) {
      throw new Error('Unexpected end of input.');
    }

    const char = this.source[this.cursor];

    switch (char) {
      case '{':
        return this.parseObject();
      case '[':
        return this.parseArray();
      case '"':
        return this.parseString();
      case 'M':
        if (this.peek(1) === '[') {
          return this.parseMap();
        }
        return this.parseBareString();
      case 'S':
        if (this.peek(1) === '[') {
          return this.parseSet();
        }
        return this.parseBareString();
      case '$':
        return this.parseTaggedMessage();
      case 'D':
        if (this.peek(1) === '"') {
          return this.parseDate();
        }
        return this.parseBareString();
      case 'U':
        if (this.peek(1) === '"') {
          return this.parseUrl();
        }
        return this.parseBareString();
      case 'B':
        if (this.peek(1) === '"') {
          return this.parseArrayBuffer();
        }
        return this.parseBareString();
      default:
        // Number, Boolean, Null, Undefined, or Bare String
        return this.parsePrimitiveOrBareString();
    }
  }

  private parseObject(): DataObject {
    this.expect('{');
    const result: DataObject = {};
    let expectedIndex = 1;

    while (this.cursor < this.length) {
      this.skipWhitespace();
      if (this.match('}')) {
        break;
      }

      // Parse potential key or value
      const token = this.parseValue();

      this.skipWhitespace();
      if (this.match(':')) {
        // It was a key. Verify it's a valid key type (String or Number).
        if (typeof token !== 'string' && typeof token !== 'number') {
          throw new TypeError(`Invalid object key: ${String(token)}`);
        }
        const key = String(token);
        const value = this.parseValue();
        result[key] = value as DataValue;

        // Update expectedIndex if numeric
        const numKey = Number(key);
        if (Number.isInteger(numKey) && numKey >= 1) {
          expectedIndex = numKey + 1;
        }
      } else {
        // Implicit key
        const key = String(expectedIndex);
        result[key] = token as DataValue;
        expectedIndex++;
      }

      this.skipWhitespace();
      if (this.match('}')) {
        break;
      }
      this.expect(',');
    }

    return result;
  }

  private parseArray(): DataArray {
    this.expect('[');
    const result: DataArray = [];

    while (this.cursor < this.length) {
      this.skipWhitespace();
      if (this.match(']')) {
        break;
      }

      result.push(this.parseValue() as DataValue);

      this.skipWhitespace();
      if (this.match(']')) {
        break;
      }
      this.expect(',');
    }

    return result;
  }

  private parseMap(): ImmutableMap<unknown, unknown> {
    this.expect('M');
    this.expect('[');
    // Map entries are arrays [key, value]
    const entries: [unknown, unknown][] = [];

    while (this.cursor < this.length) {
      this.skipWhitespace();
      if (this.match(']')) {
        break;
      }

      const entry = this.parseValue();
      if (!Array.isArray(entry) || entry.length !== 2) {
        throw new Error('Invalid map entry. Expected [key, value].');
      }
      entries.push(entry as [unknown, unknown]);

      this.skipWhitespace();
      if (this.match(']')) {
        break;
      }
      this.expect(',');
    }

    return new ImmutableMap(entries);
  }

  private parseSet(): ImmutableSet<unknown> {
    this.expect('S');
    this.expect('[');
    const values: unknown[] = [];

    while (this.cursor < this.length) {
      this.skipWhitespace();
      if (this.match(']')) {
        break;
      }

      values.push(this.parseValue());

      this.skipWhitespace();
      if (this.match(']')) {
        break;
      }
      this.expect(',');
    }

    return new ImmutableSet(values);
  }

  private parseTaggedMessage(): TaggedMessageData {
    this.expect('$');
    // Tag name is a bare string until '{'
    const start = this.cursor;
    while (this.cursor < this.length && this.source[this.cursor] !== '{') {
      this.cursor++;
    }
    const typeName = this.source.slice(start, this.cursor).trim();
    if (!typeName) {
      throw new Error('Invalid tagged message: missing type name.');
    }
    const data = this.parseObject();
    return { $tag: typeName, $data: data };
  }

  private parseDate(): Date {
    this.expect('D');
    const iso = this.parseString();
    const date = new Date(iso);
    if (Number.isNaN(date.getTime())) {
      throw new TypeError(`Invalid date value: ${iso}`);
    }
    return date;
  }

  private parseUrl(): URL {
    this.expect('U');
    const href = this.parseString();
    try {
      return new URL(href);
    } catch {
      throw new TypeError(`Invalid URL value: ${href}`);
    }
  }

  private parseArrayBuffer(): ArrayBuffer {
    this.expect('B');
    const base64 = this.parseString();
    return base64ToArrayBuffer(base64);
  }

  private parseString(): string {
    const start = this.cursor;
    this.expect('"');
    while (this.cursor < this.length) {
      const char = this.source[this.cursor];
      if (char === '\\') {
        this.cursor += 2; // Skip escaped char
        continue;
      }
      if (char === '"') {
        this.cursor++; // Consume closing quote
        const jsonString = this.source.slice(start, this.cursor);
        return JSON.parse(jsonString) as string;
      }
      this.cursor++;
    }
    throw new Error('Unterminated string literal.');
  }

  private parseBareString(): string {
    const start = this.cursor;
    while (this.cursor < this.length) {
      const char = this.source[this.cursor];
      // Stop at delimiters
      if (
        char === ':'
        || char === ','
        || char === '}'
        || char === ']'
      ) {
        break;
      }
      this.cursor++;
    }
    return this.source.slice(start, this.cursor).trim();
  }

  private parsePrimitiveOrBareString(): unknown {
    const start = this.cursor;
    // Read until delimiter
    while (this.cursor < this.length) {
      const char = this.source[this.cursor];
      if (
        char === ':'
        || char === ','
        || char === '}'
        || char === ']'
      ) {
        break;
      }
      this.cursor++;
    }
    const token = this.source.slice(start, this.cursor).trim();

    if (token === 'true') return true;
    if (token === 'false') return false;
    if (token === 'null') return null;
    if (token === 'undefined') return undefined;

    // Check for BigInt
    if (token.endsWith('n') && /^-?\d+n$/.test(token)) {
      return BigInt(token.slice(0, -1));
    }

    // Check for Number
    const num = Number(token);
    if (!Number.isNaN(num) && NUMERIC_STRING_RE.test(token)) {
      return num;
    }

    // Bare string
    if (!canUseBareString(token)) {
      throw new Error(`Invalid literal token: ${token}`);
    }

    return token;
  }

  private skipWhitespace() {
    while (this.cursor < this.length && (this.source[this.cursor] ?? '') <= ' ') {
      this.cursor++;
    }
  }

  private peek(offset = 0): string {
    return this.source[this.cursor + offset] ?? '';
  }

  private match(char: string): boolean {
    if (this.source[this.cursor] === char) {
      this.cursor++;
      return true;
    }
    return false;
  }

  private expect(char: string) {
    // eslint-disable-next-line unicorn/prefer-regexp-test -- this.match is a method, not String#match
    if (!this.match(char)) {
      throw new Error(`Expected '${char}' at position ${this.cursor}`);
    }
  }
}

function canUseBareString(value: string) {
  return (
    SIMPLE_STRING_RE.test(value)
    && !RESERVED_STRINGS.has(value)
    && !NUMERIC_STRING_RE.test(value)
  );
}

// Simple deterministic string hash (Java-style)
function hashString(value: string): number {
  let hash = 0;
  for (let i = 0; i < value.length; i += 1) {
    // eslint-disable-next-line unicorn/prefer-code-point
    hash = hash * 31 + value.charCodeAt(i) | 0;
  }
  return hash;
}

function jsonStringifyDate(value: Date | ImmutableDate): string {
  if (value instanceof Date) {
    return JSON.stringify(value.toISOString());
  }
  return JSON.stringify(value.toString());
}

function jsonStringifyUrl(value: URL): string {
  return JSON.stringify(value.toString());
}

function serializePrimitive(
  value: unknown,
  ancestors = new Set<object>()
): string {
  if (value === undefined) {
    return 'undefined';
  }

  if (Array.isArray(value) || value instanceof ImmutableArray) {
    return serializeArrayLiteral(
      Array.isArray(value) ? value : [...value],
      ancestors
    );
  }

  if (isArrayBufferValue(value)) {
    return serializeArrayBufferLiteral(unwrapArrayBuffer(value));
  }

  if (isUrlValue(value)) {
    return serializeUrlLiteral(value);
  }

  if (isMapValue(value)) {
    return serializeMapLiteral(value, ancestors);
  }

  if (isSetValue(value)) {
    return serializeSetLiteral(value, ancestors);
  }

  if (typeof value === 'bigint') {
    return `${value.toString()}n`;
  }

  if (value instanceof Message) {
    interface DescriptorGetter {
      $getPropDescriptors(): MessagePropDescriptor<DataObject>[];
    }
    const descriptors = (value as unknown as DescriptorGetter)
      .$getPropDescriptors();
    const entries = descriptors.map((d) => ({
      key: String(d.name),
      value: d.getValue(),
    }));
    return serializeObjectLiteral(entries, ancestors);
  }

  if (value && typeof value === 'object') {
    if (isDateValue(value)) {
      return `${DATE_PREFIX}${jsonStringifyDate(value)}`;
    }
    return serializeObjectLiteral(value as DataObject, ancestors);
  }

  if (typeof value === 'string') {
    if (canUseBareString(value)) {
      return value;
    }
    return JSON.stringify(value);
  }

  return JSON.stringify(value);
}

function serializeArrayLiteral(
  values: unknown[],
  ancestors = new Set<object>()
): string {
  // Track the array itself as an ancestor during serialization
  if (ancestors.has(values)) {
    throw new Error('Circular reference detected during serialization');
  }
  ancestors.add(values);
  const result = `[${values.map((value) => serializePrimitive(value, ancestors)).join(',')}]`;
  ancestors.delete(values);
  return result;
}

function serializeMapLiteral(
  entries: ReadonlyMap<unknown, unknown>,
  ancestors = new Set<object>()
): string {
  const serialized = [...entries.entries()].map(([key, value]) =>
    serializeArrayLiteral([key, value], ancestors)
  );
  return `M[${serialized.join(',')}]`;
}

function serializeSetLiteral(
  values: ReadonlySet<unknown>,
  ancestors = new Set<object>()
): string {
  return `S${serializeArrayLiteral([...values.values()], ancestors)}`;
}

function serializeTaggedMessage(
  message: Message<DataObject>,
  ancestors = new Set<object>()
): string {
  const typeName = message.$typeName;
  interface DescriptorGetter {
    $getPropDescriptors(): MessagePropDescriptor<DataObject>[];
  }
  const descriptors = (message as unknown as DescriptorGetter)
    .$getPropDescriptors();

  const entries: ObjectEntry[] = [];
  let expectedIndex = 1;

  for (const descriptor of descriptors) {
    const value = descriptor.getValue();
    const tagMessages = (descriptor.unionMessageTypes?.length ?? 0) > 0;

    if (descriptor.fieldNumber == null) {
      entries.push({ key: String(descriptor.name), value, tagMessages });
      continue;
    }

    if (value === undefined) {
      continue;
    }

    const fieldNumber = descriptor.fieldNumber;
    const shouldOmitKey = fieldNumber === expectedIndex;

    entries.push({
      key: shouldOmitKey ? null : String(fieldNumber),
      value,
      tagMessages,
    });

    expectedIndex = fieldNumber + 1;
  }

  return `$${typeName}${serializeObjectLiteral(entries, ancestors)}`;
}

function isMapValue(value: unknown): value is ReadonlyMap<unknown, unknown> {
  return value instanceof Map || value instanceof ImmutableMap;
}

function isSetValue(value: unknown): value is ReadonlySet<unknown> {
  return value instanceof Set || value instanceof ImmutableSet;
}

function isDateValue(value: unknown): value is Date {
  return value instanceof Date || value instanceof ImmutableDate;
}

function isUrlValue(value: unknown): value is URL {
  return value instanceof URL || value instanceof ImmutableUrl;
}

function isArrayBufferValue(
  value: unknown
): value is ArrayBuffer | ImmutableArrayBuffer {
  return value instanceof ArrayBuffer || value instanceof ImmutableArrayBuffer;
}

function serializeArrayBufferLiteral(buffer: ArrayBuffer): string {
  return `${ARRAY_BUFFER_PREFIX}${JSON.stringify(arrayBufferToBase64(buffer))}`;
}

function unwrapArrayBuffer(
  value: ArrayBuffer | ImmutableArrayBuffer
): ArrayBuffer {
  return value instanceof ImmutableArrayBuffer
    ? value.toArrayBuffer()
    : value;
}

function serializeUrlLiteral(url: URL): string {
  return `${URL_PREFIX}${jsonStringifyUrl(url)}`;
}

interface ObjectEntry {
  key: string | null;
  value: unknown;
  /** When true, Message values should be serialized with type tags */
  tagMessages?: boolean;
}

function serializeObjectLiteral(
  recordOrEntries: DataObject | ObjectEntry[],
  ancestors = new Set<object>()
): string {
  // Check for circular reference on the source object (not entry arrays)
  if (!Array.isArray(recordOrEntries)) {
    if (ancestors.has(recordOrEntries)) {
      throw new Error('Circular reference detected during serialization');
    }
    ancestors.add(recordOrEntries);
  }

  const entries = Array.isArray(recordOrEntries)
    ? recordOrEntries
    : Object.entries(recordOrEntries).map(([key, value]) => ({
      key,
      value,
      tagMessages: undefined,
    }));

  const serialized = entries.map(({ key, value, tagMessages }) => {
    const serializedValue = tagMessages && value instanceof Message
      ? serializeTaggedMessage(value as Message<DataObject>, ancestors)
      : serializePrimitive(value, ancestors);
    return key == null
      ? serializedValue
      : `${serializeObjectKey(key)}:${serializedValue}`;
  });

  // Remove from ancestors after processing (allows shared references)
  if (!Array.isArray(recordOrEntries)) {
    ancestors.delete(recordOrEntries);
  }

  return `{${serialized.join(',')}}`;
}

function serializeObjectKey(key: string): string {
  if (canUseBareString(key) || NUMERIC_STRING_RE.test(key)) {
    return key;
  }
  return JSON.stringify(key);
}

function arrayBufferToBase64(buffer: ArrayBuffer): string {
  if (typeof Buffer !== 'undefined') {
    return Buffer.from(buffer).toString('base64');
  }

  if (typeof btoa === 'function') {
    let binary = '';
    const view = new Uint8Array(buffer);
    for (const byte of view) {
      // eslint-disable-next-line unicorn/prefer-code-point
      binary += String.fromCharCode(byte);
    }
    return btoa(binary);
  }

  throw new Error('Base64 encoding is not supported in this environment.');
}

function base64ToArrayBuffer(encoded: string): ArrayBuffer {
  if (typeof Buffer !== 'undefined') {
    const buf = Buffer.from(encoded, 'base64');
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
  }

  if (typeof atob === 'function') {
    const binary = atob(encoded);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i += 1) {
      // eslint-disable-next-line unicorn/prefer-code-point
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes.buffer;
  }

  throw new Error('Base64 decoding is not supported in this environment.');
}

export {REACT_LISTENER_KEY, SET_UPDATE_LISTENER, FROM_ROOT, REGISTER_PATH, PROPAGATE_UPDATE, WITH_CHILD, GET_MESSAGE_CHILDREN, EQUALS_FROM_ROOT} from './symbols.js';
