import path from 'node:path';
import type { RpcEndpoint, ParseResult } from './parser.js';

/**
 * Default import path for @propane/pms-client in generated code.
 */
export const DEFAULT_CLIENT_SOURCE = '@propane/pms-client';

export interface GeneratorOptions {
  /** Name of the generated client class. Default: derived from output file name */
  className?: string;
  /** Whether to generate a WebSocket client instead of HTTP. Default: false */
  websocket?: boolean;
  /** Output file path (used for calculating relative imports and default class name) */
  outputPath: string;
  /**
   * Custom import path for @propane/pms-client in generated files.
   * Defaults to '@propane/pms-client'.
   */
  clientImportPath?: string;
}

/**
 * Convert a file name to a PascalCase class name.
 * Examples:
 *   api-client.ts -> ApiClient
 *   user_service.ts -> UserService
 *   myClient.ts -> MyClient
 */
function fileNameToClassName(outputPath: string): string {
  // Get the base name without extension
  const name = path.basename(outputPath).replace(/\.(ts|js)$/, '');

  // Split on common separators (-, _, .)
  const parts = name.split(/[-_.]+/);

  // Convert each part to PascalCase
  return parts
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join('');
}

/**
 * Generate method name from request type name.
 * GetUser -> getUser
 * UpdateRequest -> updateRequest
 */
function toMethodName(requestType: string): string {
  // Convert to camelCase (first letter lowercase)
  return requestType.charAt(0).toLowerCase() + requestType.slice(1);
}

/**
 * Calculate the relative import path from output file to source file.
 */
function getImportPath(outputPath: string, sourcePath: string): string {
  const outputDir = path.dirname(outputPath);
  let relativePath = path.relative(outputDir, sourcePath);

  // Ensure it starts with ./ or ../
  if (!relativePath.startsWith('.')) {
    relativePath = './' + relativePath;
  }

  // Change .pmsg to .pmsg.js for the compiled output
  if (relativePath.endsWith('.pmsg')) {
    relativePath += '.js';
  }

  return relativePath;
}

/**
 * Group endpoints by their source file for import generation.
 */
function groupBySourceFile(
  endpoints: RpcEndpoint[]
): Map<string, RpcEndpoint[]> {
  const groups = new Map<string, RpcEndpoint[]>();
  for (const endpoint of endpoints) {
    const existing = groups.get(endpoint.sourceFile) ?? [];
    existing.push(endpoint);
    groups.set(endpoint.sourceFile, existing);
  }
  return groups;
}

/**
 * Generate the typed PMS client code.
 */
export function generateClient(
  parseResult: ParseResult,
  options: GeneratorOptions
): string {
  const { endpoints } = parseResult;
  const className = options.className
    ?? fileNameToClassName(options.outputPath);
  const clientType = options.websocket ? 'PmwsClient' : 'PmsClient';
  const optionsType = options.websocket ? 'PmwsClientOptions' : 'PmsClientOptions';
  const clientSource = options.clientImportPath ?? DEFAULT_CLIENT_SOURCE;
  const clientImport = options.websocket
    ? `import { PmwsClient, type PmwsClientOptions } from '${clientSource}';`
    : `import { PmsClient, type PmsClientOptions } from '${clientSource}';`;

  // Group endpoints by source file for imports
  const byFile = groupBySourceFile(endpoints);

  // Generate imports
  const imports: string[] = [clientImport, ''];

  for (const [sourceFile, fileEndpoints] of byFile) {
    const importPath = getImportPath(options.outputPath, sourceFile);
    const types = new Set<string>();

    for (const endpoint of fileEndpoints) {
      types.add(endpoint.requestType);
      types.add(endpoint.responseType);
    }

    const typeList = Array.from(types).toSorted().join(', ');
    imports.push(`import { ${typeList} } from '${importPath}';`);
  }

  // Generate methods
  const methods: string[] = [];

  for (const endpoint of endpoints) {
    const methodName = toMethodName(endpoint.requestType);
    const reqType = endpoint.requestType;
    methods.push(`
  /**
   * Call ${reqType} and receive ${endpoint.responseType}.
   * @param request - ${reqType} instance or data to construct one
   */
  async ${methodName}(request: ${reqType}.Value): Promise<${endpoint.responseType}> {
    const message = ${reqType}.isInstance(request) ? request : new ${reqType}(request);
    return this.client.request(message, ${endpoint.responseType});
  }`);
  }

  // Assemble the full output
  const output = `// Generated by @propane/pms-client-compiler
// Do not edit manually

${imports.join('\n')}

/**
 * Generated PMS client with typed methods for each RPC endpoint.
 */
export class ${className} {
  private readonly client: ${clientType};

  constructor(options: ${optionsType}) {
    this.client = new ${clientType}(options);
  }
${methods.join('\n')}
}
`;

  return output;
}

/**
 * Generate a barrel export file that re-exports the client.
 */
export function generateIndex(clientPath: string): string {
  const importPath = './' + path.basename(clientPath).replace(/\.ts$/, '.js');
  return `// Generated by @propane/pms-client-compiler
export * from '${importPath}';
`;
}
