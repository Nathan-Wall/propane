import { relative, dirname, basename } from 'node:path';
import type { RpcEndpoint, ParseResult } from './parser.js';

export interface GeneratorOptions {
  /** Name of the generated client class. Default: derived from output file name */
  className?: string;
  /** Whether to generate a WebSocket client instead of HTTP. Default: false */
  websocket?: boolean;
  /** Output file path (used for calculating relative imports and default class name) */
  outputPath: string;
}

/**
 * Convert a file name to a PascalCase class name.
 * Examples:
 *   api-client.ts -> ApiClient
 *   user_service.ts -> UserService
 *   myClient.ts -> MyClient
 */
function fileNameToClassName(outputPath: string): string {
  // Get the base name without extension
  let name = basename(outputPath).replace(/\.(ts|js)$/, '');

  // Split on common separators (-, _, .)
  const parts = name.split(/[-_\.]+/);

  // Convert each part to PascalCase
  return parts
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join('');
}

/**
 * Generate method name from request type name.
 * GetUserRequest -> getUser
 * CreateUserRequest -> createUser
 */
function toMethodName(requestType: string): string {
  // Remove "Request" suffix if present
  let name = requestType;
  if (name.endsWith('Request')) {
    name = name.slice(0, -7);
  }

  // Convert to camelCase (first letter lowercase)
  return name.charAt(0).toLowerCase() + name.slice(1);
}

/**
 * Calculate the relative import path from output file to source file.
 */
function getImportPath(outputPath: string, sourcePath: string): string {
  const outputDir = dirname(outputPath);
  let relativePath = relative(outputDir, sourcePath);

  // Ensure it starts with ./ or ../
  if (!relativePath.startsWith('.')) {
    relativePath = './' + relativePath;
  }

  // Change .propane to .propane.js for the compiled output
  if (relativePath.endsWith('.propane')) {
    relativePath += '.js';
  }

  return relativePath;
}

/**
 * Group endpoints by their source file for import generation.
 */
function groupBySourceFile(endpoints: RpcEndpoint[]): Map<string, RpcEndpoint[]> {
  const groups = new Map<string, RpcEndpoint[]>();
  for (const endpoint of endpoints) {
    const existing = groups.get(endpoint.sourceFile) ?? [];
    existing.push(endpoint);
    groups.set(endpoint.sourceFile, existing);
  }
  return groups;
}

/**
 * Generate the typed PMS client code.
 */
export function generateClient(
  parseResult: ParseResult,
  options: GeneratorOptions
): string {
  const { endpoints } = parseResult;
  const className = options.className ?? fileNameToClassName(options.outputPath);
  const clientType = options.websocket ? 'PmwsClient' : 'PmsClient';
  const clientImport = options.websocket
    ? "import { PmwsClient } from '@propanejs/pms-client';"
    : "import { PmsClient } from '@propanejs/pms-client';";

  // Group endpoints by source file for imports
  const byFile = groupBySourceFile(endpoints);

  // Generate imports
  const imports: string[] = [clientImport, ''];

  for (const [sourceFile, fileEndpoints] of byFile) {
    const importPath = getImportPath(options.outputPath, sourceFile);
    const types = new Set<string>();

    for (const endpoint of fileEndpoints) {
      types.add(endpoint.requestType);
      types.add(endpoint.responseType);
    }

    const typeList = Array.from(types).sort().join(', ');
    imports.push(`import { ${typeList} } from '${importPath}';`);
  }

  // Generate methods
  const methods: string[] = [];

  for (const endpoint of endpoints) {
    const methodName = toMethodName(endpoint.requestType);
    methods.push(`
  /**
   * Call ${endpoint.requestType} and receive ${endpoint.responseType}.
   */
  async ${methodName}(request: ${endpoint.requestType}): Promise<${endpoint.responseType}> {
    return this.client.request(request, ${endpoint.responseType});
  }`);
  }

  // Assemble the full output
  const output = `// Generated by @propanejs/pms-client-compiler
// Do not edit manually

${imports.join('\n')}

/**
 * Generated PMS client with typed methods for each RPC endpoint.
 */
export class ${className} {
  constructor(private readonly client: ${clientType}) {}
${methods.join('\n')}
}
`;

  return output;
}

/**
 * Generate a barrel export file that re-exports the client.
 */
export function generateIndex(clientPath: string): string {
  const importPath = './' + basename(clientPath).replace(/\.ts$/, '.js');
  return `// Generated by @propanejs/pms-client-compiler
export * from '${importPath}';
`;
}
